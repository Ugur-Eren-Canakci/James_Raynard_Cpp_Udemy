#include <iostream>


//• Write a template function which takes two arguments of a generic type and returns the greater of the two arguments
template <typename T>
T func(T t1, T t2) {
    if (t1 < t2) return t2;
    return t1;
}
//• Write out the code for the function which is instantiated by the compiler
double func(double d1, double d2) {
    if (d1 < d2) return d2;
    return d1;
}


//Write down the definition of a template class whose members are
//• A member called "data", which has the same type as the template parameter
//• A constructor which initializes "data" from an argument of the same type

template <typename T>
class Template_Class {
private:
    T data;
public:
    Template_Class(T data) : data {data} {}
};

//Write down code to create an instance of this class with std::string as
//the parameter and the string "Hello" as the initial value of the
//member
int main() {
    
    //• Write a template function which takes two arguments of a generic type and returns the greater of the two arguments
    int bigger = func<int>(3,5);
    std::cout << bigger << std::endl;
    
    
    //Write a program which calls your function and passes arguments of type double
    std::cout << "Enter a double: ";
    double d1;
    std::cin >> d1;
    std::cout << "\nEnter another double: ";
    double d2;
    std::cin >> d2;
    std::cout << "\n" << func<double>(d1,d2) << " is bigger." << std::endl;
    
    //The normal practice is to put function declarations into a header file,
    //which is included by any source code files which call those functions.
    //The full function definition is put in a separate source code file
    //Does this method of code organization work with template functions?

    // chatgpt says no.
    // If the template's definition is in a separate source file, the compiler cannot see 
    // the definition when it needs to instantiate the template during compilation of another file.
    // Without the template definition available in the calling code's translation unit, the compiler 
    // cannot generate the required instantiations, leading to linker errors like "undefined reference to ...".
    
    //Write down code to create an instance of this class with std::string as
    //the parameter and the string "Hello" as the initial value of the
    //member

    Template_Class temp {"Hello"};

    //• Write out the class definition generated by the compiler for this instantiation
    /*
    class Template_Class {
    private:
        std::string data;
    public:
        Template_Class(std::string data) : data{data} {}
    };
     */
     
    
	return 0;
}
